1.为什么会有脏读，可重复读，提交读等
读未提交---脏读（读到了别人还未提交的事务）
读已提交---不可重复读（可以读到别人已提交的事务）
可重复读---幻读（A事务读取数据，B事务读取后更新，B提交后，A再读发现数据不一致了，因为B事务的事务id比A事务大）间隙锁+mvcc

2.spring的事务管理是如何实现的，编程式如何实现，aop式如何实现，动态代理的原理是什么，事务的传播性的理解
AOP 动态代理实现，开始事务，提交事务，回滚事务

根据接口生成动态代理对象
Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), interfaces, new InvocationHandler(){})

事务传播特性
required有就用当前事务，没有就创建一个事务
required_new每次都创建事务
support支持当前事务，但不创建新事务
not_support不支持事务
MANDATORY支持当前事务，如果没有事务抛异常
never以非事务方式执行
嵌套事务



假设有一个场景，系统需要某个特定时间内响应用户请求，比如说100ms内完成用户请求，
但是在最高峰的时候每单位时间几百万的用户请求，也就是高并发，但我必须要实现系统响应及时，而且高可用(不宕机)，假如你是架构师
高性能（高吞吐，低延迟）
    分布式-去中心化动态扩容，拆（数据库拆，缓存拆，业务代码拆(按领域拆，按性能拆，按用户优先级拆)）
    读优化-缓存（分布式缓存，jvm缓存，堆外缓存）
    写优化-读写分离（批量写，顺序写）
    异步化（多线程，mq）
    代码优化（集合，线程上下文切换，锁竞争，算法复杂度）
    jvm优化（垃圾回收器器调优）
    网络优化（net参数）

高可用
    主从互备
    nginx负载均衡
    监控告警
    分组隔离（性能，业务，重要性，实时性，）
    限流降级熔断
    异地多活（业务阉割，保证核心业务可用）


jvm的类加载机制
class字节码---classLoader  loadclass,findclass  解析校验实例化初始化
委托双亲机制 先看父亲能干不，能干让父亲干，干不了在自己干
反射机制是如何利用类加载机制的呢


二叉树的深度遍历 递归，非递归

spring是如何管理zookeeper
了解zookeeper的leader选取算法吗，讲一下他的流程，知道zab算法吗，讲一下他的流程
事务id，服务器id

读写锁中加读锁后如何避免写线程饿死，答：加策略balabala，发问如何实现
公平锁，构造器指定，新加入的任务是否参与竞争锁，保证先进来了先处理，避免锁饥饿



jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代，几种主要的jvm参数等
eden-->s0-->s1---old
eden-->old(平均晋升阈值)
G1里还有大对象区域

你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms
新生代 复制算法（串行，并行，并发parNew）
年老代 串行，并行，cms，G1（新老通吃）

cms4个阶段
初始化标记：标记root（STW）
并发标记：从root触发并发标记可触达对象（多线程）
再标记：标记一下并发出现的新对象（STW）
清除对象：清理对象(多线程)
如果old对象占用68%内存，进行全局串行fullgc


G1
新生代回收-并发复制回收，动态调整eden和s0s1
老年代回收
    初始化标记
    根区域扫描
    并发标记
    重新标记
    独占清理
混合回收
必要时的串行full gc

当出现了内存溢出，你怎么排错
查看线程，内存监控，查看磁盘，网络监控
jmap-->dump--->mat  分析对象数量太多
分析线程阻塞数过多
分析网络netstat  close_wait过多是否阻塞线程

JVM内存模型的相关知识了解多少
栈（计数器，局部变量，本地方法栈）
堆（新生代，老年代，持久代）
元空间-堆外内存

简单说说你了解的类加载器
classLoad.loadClass--->findclass
用户调用loadClass里的通过findClass来找class,然后反射调用构造器实例化对象


JAVA的反射机制
通过class来访问构造器，方法，属性，修饰符，注解等


http1.0和http1.1有什么区别
默认长链接 keepalive
2.0支持多路复用，头部压缩，服务器推送


TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么
第3次握手是要确认无误建立连接--表明我认为的和对方认为的是一个回事，别认错人
四次挥手是由于TCP是全双工的，同时发数据，接收数据，所以停止发数据需要两次确认，停止接受也需要2次确认

TIME_WAIT和CLOSE_WAIT的区别
close_wait是服务端接收到客户端断开连接请求后的状态
time_wait是客户端接受到服务端主动断开连接的请求后的状态

说说你知道的几种HTTP响应码
404
302
500

架构设计与分布式

tomcat如何调优，各种参数的意义
连接池 连接超时时间，连接IO复用器
线程池 核心线程，最大线程数，线程队列长度，空闲时间，拒绝策略
jvm 新生代，年老代，比例空间，垃圾回收器，并发线程数，日志，dump等


常见的缓存策略有哪些，
redis
你们项目中用到了什么缓存系统，如何设计的，

Redis的使用要注意什么，持久化方式，内存设置，集群，淘汰策略等

如何防止缓存雪崩
服务降级，降级开关，mock数据
客户端限流
集群切换
本地缓存

分布式集群下如何做到唯一序列号

设计一个秒杀系统，30分钟没付款就自动关闭交易

如何做一个分布式锁
setnx+lua 超时时间，key中uuid+线程id
reddsion分布式

用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗
activeMq，kafka,rocketMq
activeMq不是分布式的
kafka大数据
rocketMq 事务消息，有序消息，延时消息，消息追溯，

MQ系统的数据如何保证不丢失
单broken内有commitlog消息日志，系统落盘，重启恢复数据
主从复制防止主未成功，从还可以成功，ack确认机制

分布式事务的原理，如何使用分布式事务
二阶段提交
三阶段提交
tcc
最终一致性

本地消息表，tcc,二阶段提交


什么是一致性hash
treeMap实现一个hash环，客户端顺时针查找服务器所在节点（有可能是虚拟节点，以便于均摊流量流量）
在某个服务down了的时候，可以顺时针去找下一个服务，不会直接丢弃

说说你知道的几种HASH算法，简单的也可以

什么是Paxos、Raft
选举一致性算法，大概流程
没有leader后，都推选自己是领导，周知所有人，当超过一半选票的节点变成leader(有可能不是最终的leader,因为有超时时间)


redis和memcached 的内存管理的区别等等



你觉得你来百度能给百度带来什么样的价值，
你希望你加入的百度的团队是一个什么样的团队，
你如何和产品经理沟通，
你和其他研发接口制定无法统一你该如何解决等，






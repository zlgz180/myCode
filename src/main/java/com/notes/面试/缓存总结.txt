库存信息实时性高，一般情况：数据库缓存双写不一致

解决方案1：先删缓存，在更新数据库，解决了删缓存成功，数据库失败时，缓存是空的，不会出现不一致

进阶情况，先删缓存，再更新数据库，但是更新数据库之前并发读请求来进行回填缓存，导致数据库是更新后的数据，缓存是更新前的数据
解决方案2：


a.分布式锁给读写加一把锁,或者多把锁（hash拆分锁）
b.先删缓存，更新数据库，如果出现并发读导致缓存不一致(缓存时间是old mysql时间)，可以来订阅数据库的binlog，和缓存比较，如果
	时间晚则覆盖
		binlog并发更新（顺序，并发？）
c.读写jvm队列异步处理，读hold,写串行，请求流量hash均匀分布到jvm
	

metadata(元数据)实时性要求低，可以考虑多级缓存
nginx 本地缓存+ redis集群缓存 + Tomcat jvm缓存

	
集群雪崩
事前：缓存集群高可用
事中：流量拖库，配置中心开启服务限流，本地缓存尽量抗流量


缓存命中率
hash分片(双层proyx，nginx流量分发)
咖啡因本地缓存，时间片+LRU
异步/同步更新


缓存预热
rpc，启动初始化

graua